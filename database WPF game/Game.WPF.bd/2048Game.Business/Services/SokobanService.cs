using System;
using System.Collections.Generic;
using System.Linq;
using _2048Game.Business.Models;

namespace _2048Game.Business.Services
{
    public class SokobanService
    {
        public SokobanBoard Board { get; private set; }
        public event Action BoardUpdated;
        public event Action LevelCompleted;
        public event Action<int,int> BoxPlaced; // row,col

        private readonly Random _random = new Random();
        public SokobanService()        {            // default random level            StartRandomLevel();        }        public SokobanService(SokobanBoard board)        {            if (board == null)                StartRandomLevel();            else            {                Board = board;                BoardUpdated?.Invoke();            }        }        public void StartDefaultLevel()        {            var template = new int[7,9]            {                {1,1,1,1,1,1,1,1,1},                {1,0,0,0,0,0,0,3,1},                {1,0,2,2,3,1,0,0,1},                {1,0,0,0,0,1,0,0,1},                {1,0,0,4,0,0,0,0,1},                {1,0,0,0,0,0,0,0,1},                {1,1,1,1,1,1,1,1,1}            };            Board = new SokobanBoard(7, 9);            Board.LoadFromArray(template);            BoardUpdated?.Invoke();        }        public void StartRandomLevel(int boxesCount = 2, int obstaclesCount = 6, int maxAttempts = 50)        {            int rows = 7, cols = 9;            for (int attempt = 0; attempt < maxAttempts; attempt++)            {                var board = new SokobanBoard(rows, cols);                // initialize empty with walls border                for (int r = 0; r < rows; r++)                    for (int c = 0; c < cols; c++)                        board.Cells[r, c] = (r == 0 || r == rows - 1 || c == 0 || c == cols - 1) ? 1 : 0;                var innerCells = new List<(int r, int c)>();                for (int r = 1; r < rows - 1; r++)                    for (int c = 1; c < cols - 1; c++)                        innerCells.Add((r, c));                // place internal obstacles                var free = new List<(int r, int c)>(innerCells);                for (int i = 0; i < obstaclesCount && free.Count > 0; i++)                {                    int idx = _random.Next(free.Count);                    var (r, c) = free[idx];                    board.Cells[r, c] = 1; // wall                    free.RemoveAt(idx);                }                // choose player position from remaining free cells                if (free.Count == 0) continue;                var playerPos = free[_random.Next(free.Count)];                board.Cells[playerPos.r, playerPos.c] = 4;                board.PlayerPosition = playerPos;                free.Remove(playerPos);                // compute reachable cells from player ignoring boxes/targets                var reachable = ComputeReachable(board, playerPos);                // need enough reachable cells to place boxes and targets and some space                if (reachable.Count < boxesCount * 3 + 1)                {                    // try again                    continue;                }                // choose distinct target positions within reachable (not player)                var reachableList = reachable.ToList();                // remove player pos                reachableList.RemoveAll(x => x.r == playerPos.r && x.c == playerPos.c);                if (reachableList.Count < boxesCount * 2) continue;                var targets = new List<(int r, int c)>();                for (int i = 0; i < boxesCount; i++)                {                    int idx = _random.Next(reachableList.Count);                    targets.Add(reachableList[idx]);                    reachableList.RemoveAt(idx);                }                // place targets                foreach (var t in targets)                    board.Cells[t.r, t.c] = 3;                // choose boxes positions from reachableList (ensure not on targets)                var boxes = new List<(int r, int c)>();                for (int i = 0; i < boxesCount; i++)                {                    if (reachableList.Count == 0) break;                    int idx = _random.Next(reachableList.Count);                    boxes.Add(reachableList[idx]);                    reachableList.RemoveAt(idx);                }                if (boxes.Count < boxesCount) continue; // try again                foreach (var b in boxes)                    board.Cells[b.r, b.c] = 2;                // accept board                Board = board;                BoardUpdated?.Invoke();                return;            }            // fallback to default if generation failed            StartDefaultLevel();        }        private HashSet<(int r, int c)> ComputeReachable(SokobanBoard board, (int r, int c) start)        {            var visited = new HashSet<(int r, int c)>();            var q = new Queue<(int r, int c)>();            q.Enqueue(start);            visited.Add(start);            int rows = board.Rows, cols = board.Cols;            while (q.Count > 0)            {                var (r, c) = q.Dequeue();                var deltas = new (int dr, int dc)[] { (-1,0),(1,0),(0,-1),(0,1) };                foreach (var d in deltas)                {                    int nr = r + d.dr, nc = c + d.dc;                    if (nr <= 0 || nr >= rows - 1 || nc <= 0 || nc >= cols - 1) continue;                    if (visited.Contains((nr, nc))) continue;                    // cell is walkable if not a wall                    if (board.Cells[nr, nc] != 1)                    {                        visited.Add((nr, nc));                        q.Enqueue((nr, nc));                    }                }            }            return visited;        }        public void Move(SokobanDirection dir)        {            var moved = Board.Move(dir);            if (moved)            {                // first notify UI of updated board                BoardUpdated?.Invoke();                // then raise BoxPlaced events for any newly placed boxes                foreach (var (r, c) in Board.LastPlacedPositions)                    BoxPlaced?.Invoke(r, c);                if (Board.IsWin())                    LevelCompleted?.Invoke();            }        }    }}